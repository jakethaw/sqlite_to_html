<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>SQLite to HTML</title>
    <style>
      td {
          vertical-align: top;
          padding-bottom: 5px;
          padding-right: 20px;
      }
    </style>
  </head>
  <body>
    <h1>SQLite to HTML</h1>
    
    <p>
      <a href="https://github.com/jakethaw/sqlite_to_html">github.com/jakethaw/sqlite_to_html</a>
    </p>
    
    <p>
      <select name="file" id="file" onchange="select_file()">
        <option value="graph.sql">graph.sql</option>
        <option value="affine.sql">affine.sql</option>
        <option value="dragon.sql">dragon.sql</option>
        <option value="serpinski.sql">serpinski.sql</option>
        <option value="cubes.sql">cubes.sql</option>
      </select>
    </p>
    
    <table>
      <tr>
        <td>
          <textarea id="sql" wrap="off" rows="35" cols="80"></textarea>
          <br>
          <div id="error" style="color:red"></div>
        </td>
        <td>
          <div id="svg"></div>
        </td>
      </tr>
    </table>

    <script async>

      let timer = 0;
      let file = document.getElementById("file").value;
      let eval_wait = 0;

      // https://emscripten.org/docs/api_reference/module.html
      var Module = {
        'onRuntimeInitialized': async function() { 
          await select_file();
          // Evaluate every 30ms
          setInterval(eval_sql, 30); 
        },
        'noInitialRun': true,
        'printErr': function(text) { document.getElementById("error").innerText += text + '\n'; }
      };

      // Run content of textarea in SQLite CLI
      function eval_sql(){
        if( eval_wait == 0 ){
          eval_wait = 1;
          const sql = document.getElementById("sql").value;
          FS.writeFile(file, sql);
          document.getElementById("error").innerText = '';
          sqlite_main([
            ':memory:',
            '.param init',
            `.param set $timer ${timer}`,
            `.read ${file}`
          ]);
          document.getElementById('svg').innerHTML = FS.readFile('output.svg', { encoding: 'utf8' });
          eval_wait = 0;
        }
        timer += 1;
      }

      // Call SQLite shell main function
      function sqlite_main(args){
          let argc = args.length+1;
          let argv = _malloc((argc + 1) * 4);
          HEAP32[argv >> 2] = allocateUTF8(thisProgram);
          for (let i = 1; i < argc; i++) {
            HEAP32[(argv >> 2) + i] = allocateUTF8(args[i - 1]);
          }
          HEAP32[(argv >> 2) + argc] = 0;

          let ret = Module['_main'](argc, argv);

          _free(HEAP32[argv >> 2]);
          for (let i = 1; i < argc; i++) {
            _free(HEAP32[(argv >> 2) + i]);
          }
          _free(argv);
      }

      async function select_file(){
        try {
          let e = document.getElementById("file");
          file = e.options[e.selectedIndex].value;
          timer = 0;

          // Get file
          await fetch(file)
            .then(response => response.text())
            .then(data => {
              document.getElementById("sql").value = data;
              FS.writeFile(file, data);
            });

        } catch(e) { console.log(e); }
      }
    </script>
    <script async type="text/javascript" src="sqlite3.js"></script>

  </body>
</html>